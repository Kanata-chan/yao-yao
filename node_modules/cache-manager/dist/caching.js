"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCache = exports.caching = void 0;
const promise_coalesce_1 = require("promise-coalesce");
const stores_1 = require("./stores");
/**
 * Generic caching interface that wraps any caching library with a compatible interface.
 */
async function caching(factory, args) {
    if (factory === 'memory') {
        const store = (0, stores_1.memoryStore)(args);
        return createCache(store, args);
    }
    if (typeof factory === 'function') {
        const store = await factory(args);
        return createCache(store, args);
    }
    const store = factory;
    return createCache(store, args);
}
exports.caching = caching;
/**
 * Create cache instance by store (non-async).
 */
function createCache(store, args) {
    return {
        /**
         * Wraps a function in cache. I.e., the first time the function is run,
         * its results are stored in cache so subsequent calls retrieve from cache
         * instead of calling the function.
    
         * @example
         * const result = await cache.wrap('key', () => Promise.resolve(1));
         *
         */
        wrap: async (key, fn, ttl) => {
            return (0, promise_coalesce_1.coalesceAsync)(key, async () => {
                const value = await store.get(key);
                if (value === undefined) {
                    const result = await fn();
                    const cacheTTL = typeof ttl === 'function' ? ttl(result) : ttl;
                    await store.set(key, result, cacheTTL);
                    return result;
                }
                else if (args?.refreshThreshold) {
                    const cacheTTL = typeof ttl === 'function' ? ttl(value) : ttl;
                    const remainingTtl = await store.ttl(key);
                    if (remainingTtl !== -1 && remainingTtl < args.refreshThreshold) {
                        (0, promise_coalesce_1.coalesceAsync)(`+++${key}`, fn).then((result) => store.set(key, result, cacheTTL));
                    }
                }
                return value;
            });
        },
        store: store,
        del: (key) => store.del(key),
        get: (key) => store.get(key),
        set: (key, value, ttl) => store.set(key, value, ttl),
        reset: () => store.reset(),
    };
}
exports.createCache = createCache;
//# sourceMappingURL=caching.js.map