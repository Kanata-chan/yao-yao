"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multiCaching = void 0;
/**
 * Module that lets you specify a hierarchy of caches.
 */
function multiCaching(caches) {
    const get = async (key) => {
        for (const cache of caches) {
            try {
                const val = await cache.get(key);
                if (val !== undefined)
                    return val;
            }
            catch (e) { }
        }
    };
    const set = async (key, data, ttl) => {
        await Promise.all(caches.map((cache) => cache.set(key, data, ttl)));
    };
    return {
        get,
        set,
        del: async (key) => {
            await Promise.all(caches.map((cache) => cache.del(key)));
        },
        async wrap(key, fn, ttl) {
            let value;
            let i = 0;
            for (; i < caches.length; i++) {
                try {
                    value = await caches[i].get(key);
                    if (value !== undefined)
                        break;
                }
                catch (e) { }
            }
            if (value === undefined) {
                const result = await fn();
                const cacheTTL = typeof ttl === 'function' ? ttl(result) : ttl;
                await set(key, result, cacheTTL);
                return result;
            }
            else {
                const cacheTTL = typeof ttl === 'function' ? ttl(value) : ttl;
                Promise.all(caches.slice(0, i).map((cache) => cache.set(key, value, cacheTTL))).then();
                caches[i].wrap(key, fn, ttl).then(); // call wrap for store for internal refreshThreshold logic, see: src/caching.ts caching.wrap
            }
            return value;
        },
        reset: async () => {
            await Promise.all(caches.map((x) => x.reset()));
        },
        mget: async (...keys) => {
            const values = new Array(keys.length).fill(undefined);
            for (const cache of caches) {
                if (values.every((x) => x !== undefined))
                    break;
                try {
                    const val = await cache.store.mget(...keys);
                    val.forEach((v, i) => {
                        if (values[i] === undefined && v !== undefined)
                            values[i] = v;
                    });
                }
                catch (e) { }
            }
            return values;
        },
        mset: async (args, ttl) => {
            await Promise.all(caches.map((cache) => cache.store.mset(args, ttl)));
        },
        mdel: async (...keys) => {
            await Promise.all(caches.map((cache) => cache.store.mdel(...keys)));
        },
    };
}
exports.multiCaching = multiCaching;
//# sourceMappingURL=multi-caching.js.map